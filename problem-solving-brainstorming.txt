May 16, 2020

The goal of this session is for us to generally practice problem solving with as many questions as possible, and brainstorm as many different solutions as we can.

#1. Palindrome
Problem: given a string, write a program to determine if it's a Palindrome

* Recursively check
    * base case is if it's an empty string
    * or if it's length 1
    * if it's length 2
    * recursive case:
        * check last == first and recurse(string[1:-1])

* Create a list of the reversed letters
    * loop over both lists at the same time and check that characters are the same

* dynamic programming:
    *

* make the string a stack
    * for each letter, loop through and check the last element on the stack: if they're equal, pop and continue.
    * if they're unequal, return False
    * else, at the end of the loop return True

# Sam:
    * 1. Str -> Array -> Reverse -> check for equality
    * 2. Two pointers, one at end and one at beginning.
    * 3. Recursive solution: base case is length 1
# Chloe:
    * 1. Reversing the string
    * 2. Go halfway through the string with the ith character and the -ith character
    * 3. Cut string in half and cut for equality, and if it's odd, take out middle letter
    * 4.


#2. Balanced Parentheses

* Recursively check:
    * Only keep '(', ')'
    * if string is empty, return True
    * Loop through string:
        * if open, find next close
            * if cannot find, return False
        * else recurse by removing open and corresponding close

* stack-based approach
    * loop through each character:
        * if open parenthesis, push onto the stack
        * if close paranthesis: pop off of the stack (if can't, return False)
    * true when loop is done, stack is empty


# Chloe
* Also came up with stack-based approach
* Recurse: for each string take off end Parentheses

# Sam
* Using a hashmap that is a counter


June 20, 2020

BFS, DFS and Dijkstra's algorithm


1. First, let's talk about what DFS, BFS are:
    * What are they for, compare-contrast?
        * bfs - exiting first when found, minimum
        * dfs - trying to find things in a greedy fashion, good if you know solutions may be deep in a tree, stuff like tic-tac-toe leading to a win
            * less memory
    * What do they take as input and what do they output?
        * take in a graph/tree, return can be arbitrarily a number
    * In high level terms, how do they work?
        * bfs - searches through "each level"
        * dfs - searches through one "strand" from tree to root



2. Implementation details
    * Let's implement BFS
    * Now let's implement DFS
    * What is the only difference from an implementation perspective?
    * Now let's implement Dijkstra's <- save for next time?


3. Now let's solve problems:
    * Perfect Squares: https://leetcode.com/problems/perfect-squares/
    * Number of Islands https://leetcode.com/problems/number-of-islands/
        * BFS, but start at the first '1' in the array (and increment an island_counter by 1) and only add to frontier if it's a '1'
        * when the queue is empty, start at the next '1' that has yet to be searched
        * if there are no more '1's left, return island_counter
    * Challenge: Jugs Problem


4. Next week:
    * Dijkstra's
    * A-star
    * Solve problems