

## Exercism

# Homework is to go to exercism.io and solve a number of problems, while following the problem-solving process discussed in Polya and in class.

# Problem 1: Knapsack Problem
"""
In this exercise, let's try to solve a classic problem.

Bob is a thief. After months of careful planning, he finally manages to crack the security systems of a high-class apartment.

In front of him are many items, each with a value (v) and weight (w). Bob, of course, wants to maximize the total value he can get; 
he would gladly take all of the items if he could. However, to his horror, he realizes that the knapsack he carries with him can only hold so much weight (W).

Given a knapsack with a specific carrying capacity (W), help Bob determine the maximum value he can get from the items in the house. Note that Bob can take only one of each item.

All values given will be strictly positive. Items will be represented as a list of pairs, wi and vi, where the first element wi is the weight of the ith item and vi is the value for that item.

For example:

Items: [ { "weight": 5, "value": 10 }, { "weight": 4, "value": 40 }, { "weight": 6, "value": 30 }, { "weight": 4, "value": 50 } ]

Knapsack Limit: 10

For the above, the first item has weight 5 and value 10, the second item has weight 4 and value 40, and so on.

In this example, Bob should take the second and fourth item to maximize his value, which, in this case, is 90. He cannot get more than 90 as his knapsack has a weight limit of 10.
"""


# Step 1: Understanding the problem:
# > Input = list of dictionaries, each with two keys: weight and value. 
# > Output = list of dictionaries such that the sum of the values for 'weight' keys is under the limit and the sum of the values for the 'value' key is the maximum value given the limit.
# > Actually after rereading the problem the output is just the maximum value he can take.

# Step 2: Using different problem-solving approaches
"""
Strategy 1:
* create a list of all values that can be generated by combinations of items (This would be O(n!) unfortunately)
* sort the list from big to small
* now go through this list from big to small and:
    * cross off each combination if the weight exceeds the limit
* stop at the first combination where the weight does not exceed the limit

Other ideas after doodling:
* Calculate the value per weight ratio and take the highest N ones until you exceed the weight limit
* This smells like a constrainted optimization problem


Strategy 2:
* Calculate the value per weight ratio for all items
* sort by this ratio
* but this runs into the problem when it's actually optimal to take something that has a smaller ratio (e.g,. if the limit was 100 [{"weight": 50, "value": 50}, {"weight": 100, "value": 90}] -- it would be optimal to take the 100 weight one even though it's ratio is lower)

Strategy 3:
Another idea after coming up with Strategy 2:
* there's a recursive / branching solution here: between all options, take the first one and calculate value of remaining



Another idea as I was staring at my notebook:

I could graph (weight, value) coordinates and treat them as vectors. I am trying to maximize value subject to weight sums < limit. I probably could use some strategies
from geometry / vector spaces here (? maybe?). 
Add the coordinates / vectors together?
"""

# Strategy No. 3
# I'm going to start by implementing this strategy
import copy

memory = {}
# This was my first attempt at a recursive.
# It took me a little bit of time to realize I had to add the `if weight_limit - item_weight >= 0` condition in the for-loop.
# I also believe this is a O(N!) (yikes!) solution. It doesn't even finish running on 15 items (15! is ~1.3tn)
# My next thoughts are to cache results to speed things up.
def maximum_value(weight_limit, items):
    """
        Returns maximum value given the items

        Algorithm:
            Base case: there is only one item. Then check if it's possible to take it.
            For each item, put it in your bag and see what the maximum value of the remaining items / weight limit are now.
    """

    if weight_limit <= 0:
        return 0

    if len(items) == 1:
        item = items[0]
        if item['weight'] <= weight_limit:
            return item['value']
        else:
            return 0

    values = []
    for item in items:
        item_value = item['value']
        item_weight = item['weight']

        if weight_limit - item_weight >= 0: # checks if we can keep the current item
            copied_items = copy.deepcopy(items)
            copied_items.remove(item)
            # Recursively find the solution if we packed the current item and then all items except the current
            total_value = item_value + maximum_value(weight_limit - item_weight, copied_items)
        else: # this path is a dead end, so break out of the loop
            total_value = 0
        
        values.append(total_value)
    maximum = max(values)
    return maximum

test_items = [ 
    { "weight": 5, "value": 10 }, 
    { "weight": 4, "value": 40 }, 
    { "weight": 6, "value": 30 }, 
    { "weight": 4, "value": 50 } 
]

test_items2 = [ 
    { "weight": 5, "value": 10 },
    { "weight": 10, "value": 11 },
    { "weight": 10, "value": 11 }
]

test_items3 =  [
    {"weight": 2, "value": 5},
    {"weight": 2, "value": 5},
    {"weight": 2, "value": 5},
    {"weight": 2, "value": 5},
    {"weight": 10, "value": 21}
]

test_items4 = [
    {"weight": 2, "value": 20},
    {"weight": 2, "value": 20},
    {"weight": 2, "value": 20},
    {"weight": 2, "value": 20},
    {"weight": 10, "value": 50}
]

test_items5 = [
    {"weight": 25, "value": 350},
    {"weight": 35, "value": 400},
    {"weight": 45, "value": 450},
    {"weight": 5, "value": 20},
    {"weight": 25, "value": 70},
    {"weight": 3, "value": 8},
    {"weight": 2, "value": 5},
    {"weight": 2, "value": 5}
]

test_items6 = [
    {"weight": 70, "value": 135},
    {"weight": 73, "value": 139},
    {"weight": 77, "value": 149},
    {"weight": 80, "value": 150},
    {"weight": 82, "value": 156},
    {"weight": 87, "value": 163},
    {"weight": 90, "value": 173},
    {"weight": 94, "value": 184},
    {"weight": 98, "value": 192},
    {"weight": 106, "value": 201},
    {"weight": 110, "value": 210},
    {"weight": 113, "value": 214},
    {"weight": 115, "value": 221},
    {"weight": 118, "value": 229},
    {"weight": 120, "value": 240}
]

# Testing with 15 items takes forever due to ~15! = 1,307,674,368,000 (1.3 trillion) recursive calls. Need to memoize/cache results.
print(maximum_value(750, test_items6))